import { formatDate, parseDate } from '@openmrs/esm-framework';

export function getEncounterValues(encounter: Record<string, string>, param: string, isDate?: boolean) {
  if (isDate) {
    return formatDate(parseDate(encounter[param]));
  } else {
    return encounter[param] ? encounter[param] : '--';
  }
}

export function formatDateTime(dateString: string): string {
  if (dateString.includes('.')) {
    dateString = dateString.split('.')[0];
  }
  return formatDate(parseDate(dateString));
}

export function obsArrayDateComparator(left: { obsDatetime: string }, right: { obsDatetime: string }) {
  return new Date(right.obsDatetime).getTime() - new Date(left.obsDatetime).getTime();
}

export function findObs(encounter: Record<string, any>, obsConcept: string): Record<string, any> {
  const allObs = encounter?.obs?.filter((observation) => observation.concept.uuid === obsConcept) || [];
  return allObs?.length == 1 ? allObs[0] : allObs?.sort(obsArrayDateComparator)[0];
}

export function getObsFromEncounters(encounters: Array<Record<string, any>>, obsConcept: string) {
  const filteredEnc = encounters?.find((enc) => enc.obs.find((obs) => obs.concept.uuid === obsConcept));
  return getObsFromEncounter(filteredEnc, obsConcept);
}

export function getMultipleObsFromEncounter(encounter: Record<string, any>, obsConcepts: Array<string>) {
  let observations = [];
  obsConcepts.map((concept) => {
    const obs = getObsFromEncounter(encounter, concept);
    if (obs !== '--') {
      observations.push(obs);
    }
  });

  return observations.length ? observations.join(', ') : '--';
}

export function getObsFromEncounter(encounter: Record<string, any>, obsConcept: string, isDate?: boolean, isTrueFalseConcept?: boolean) {
  const obs = findObs(encounter, obsConcept);

  if (isTrueFalseConcept) {
    if (obs.value.uuid == 'cf82933b-3f3f-45e7-a5ab-5d31aaee3da3') {
      return 'Yes';
    } else {
      return 'No';
    }
  }
  if (!obs) {
    return '--';
  }
  if (isDate) {
    return formatDate(parseDate(obs.value), { mode: 'wide' });
  }
  if (typeof obs.value === 'object' && obs.value?.names) {
    return (
      obs.value?.names?.find((conceptName) => conceptName.conceptNameType === 'SHORT')?.name || obs.value.name.name
    );
  }
  if (typeof obs.value === 'object' && obs.value !== null) {
    return obs.value.display ?? '--';
  }
  return obs.value;
}

export function mapObsValueToFormLabel(
  conceptUuid: string,
  answerConceptUuid: string | undefined,
  formConceptMap: Record<string, { display?: string; answers?: Record<string, string> }>,
  defaultValue: string | number | Record<string, any> | null,
): string {
  if (typeof defaultValue === 'number') {
    // check early if value is number and return
    return String(defaultValue);
  }

  const conceptMapOverride = formConceptMap !== undefined && Object.keys(formConceptMap).length > 0;
  if (conceptMapOverride && answerConceptUuid !== undefined) {
    // check for boolean concepts
    if (answerConceptUuid === '1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA') {
      answerConceptUuid = '0';
    } else if (answerConceptUuid === '2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA') {
      answerConceptUuid = '1';
    }
    let theDisplay = formConceptMap[conceptUuid]?.answers[answerConceptUuid];

    if (typeof theDisplay !== 'undefined') {
      return theDisplay;
    } else {
      return extractDefaultValueBasedOnType(defaultValue);
    }
  } else if (!conceptMapOverride || answerConceptUuid !== undefined) {
    if (typeof defaultValue === 'object' && defaultValue !== null) {
      return (defaultValue as Record<string, any>)['name']?.['name'] ?? '--'; // extract the default name from the object
    }
  } else {
    return extractDefaultValueBasedOnType(defaultValue);
  }
  return '--';
}

function extractDefaultValueBasedOnType(defaultValue: string | number | Record<string, any> | null): string {
  if (defaultValue === null || defaultValue === undefined) {
    return '--';
  }
  const typeOfVal = typeof defaultValue;

  if (typeOfVal === 'number') {
    return String(defaultValue);
  }
  if (typeOfVal === 'string') {
    const strValue = defaultValue as string;
    const stringParts = strValue.split(':');
    if (stringParts.length === 0 || stringParts.length === 1) {
      return strValue;
    } else if (stringParts.length === 2) {
      return stringParts[1];
    } else {
      // TODO: identify other cases to support here
      // check for date
      return formatDate(parseDate(strValue));
    }
  } else if (typeOfVal === 'object') {
    return (defaultValue as Record<string, any>)['name']?.['name'] ?? '--'; // extract the default name from the object
  }
  return '--';
}
export function mapConceptToFormLabel(conceptUuid: string, formConceptMap: Record<string, { display?: string; answers?: Record<string, string> }>, defaultValue: string): string {
  if (formConceptMap === undefined) {
    return defaultValue;
  }

  let theDisplay = formConceptMap[conceptUuid] ? formConceptMap[conceptUuid].display : defaultValue;

  return theDisplay;
}

/**
 * This is a util method stub for generating the mapping for labels in the form schema
 * It should be moved to an appropriate place if not here
 */
export function generateFormLabelsFromJSON() {
  const htsScreeningJson = { pages: [] };
  const result = {};
  htsScreeningJson.pages.forEach((page) => {
    page.sections.forEach((section) => {
      section.questions.forEach((question) => {
        let answersMap = {};
        let questionObject = {};
        question.questionOptions.answers?.forEach((ans) => {
          answersMap[ans.concept] = ans.label;
        });
        questionObject['display'] = question.label;
        questionObject['answers'] = answersMap;
        result[question.questionOptions.concept] = questionObject;
      });
    });
  });
}
